package radvdmanager

import (
	"crypto/sha256"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"natman/link"
	rad "natman/link/radv"
)

// It creates a radvd configuration file based on the provided configuration.
// compares the hash of existing file /etc/radvd.conf with the hash of the new file
// if they are different, it writes the new file to /etc/radvd.conf
// and restarts the radvd service
func CreateRadvdConfig(links map[string]*link.Link) error {
	fmt.Println("Creating radvd configuration file...", rad.RadvdConfPath)

	// Generate new configuration
	newConfig := generateRadvdConfig(links)

	// Calculate hash of new config
	newHash := calculateHash(newConfig)

	// Read existing config and calculate its hash
	existingConfig, err := os.ReadFile(rad.RadvdConfPath)
	var existingHash string
	if err == nil {
		existingHash = calculateHash(string(existingConfig))
	}

	// Compare hashes
	if newHash == existingHash {
		fmt.Println("Radvd configuration unchanged, skipping update")
		return nil
	}

	// Write new configuration
	err = os.WriteFile(rad.RadvdConfPath, []byte(newConfig), 0644)
	if err != nil {
		return fmt.Errorf("failed to write radvd config: %v", err)
	}

	// Restart radvd service
	if err := restartRadvdService(); err != nil {
		return fmt.Errorf("failed to restart radvd service: %v", err)
	}

	fmt.Println("Radvd configuration updated and service restarted")
	return nil
}

func generateRadvdConfig(links map[string]*link.Link) string {
	var config strings.Builder

	config.WriteString("# Generated by natman-go\n")
	config.WriteString("# Do not edit manually\n\n")

	for linkName, linkObj := range links {
		if linkObj.Radv != nil && linkObj.Radv.Enabled {
			interfaceConfig := linkObj.Radv.GenerateConfig(linkName)
			config.WriteString(interfaceConfig)

			// Add include files if specified
			for _, includeFile := range linkObj.Radv.Include {
				if _, err := os.Stat(includeFile); err == nil {
					includeContent, err := os.ReadFile(includeFile)
					if err == nil {
						config.WriteString(fmt.Sprintf("# Included from %s\n", includeFile))
						config.WriteString(string(includeContent))
						config.WriteString("\n")
					}
				}
			}
		}
	}

	return config.String()
}

func calculateHash(content string) string {
	hash := sha256.Sum256([]byte(content))
	return fmt.Sprintf("%x", hash)
}

func restartRadvdService() error {
	// Try systemctl first
	cmd := exec.Command("systemctl", "restart", "radvd")
	if err := cmd.Run(); err == nil {
		return nil
	}

	// Try service command as fallback
	cmd = exec.Command("service", "radvd", "restart")
	if err := cmd.Run(); err == nil {
		return nil
	}

	// Try init.d script as last resort
	cmd = exec.Command("/etc/init.d/radvd", "restart")
	return cmd.Run()
}

func ValidateRadvdConfig() error {
	cmd := exec.Command("radvd", "-c", "-C", rad.RadvdConfPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("radvd config validation failed: %s", string(output))
	}
	return nil
}

func GetRadvdStatus() (bool, error) {
	cmd := exec.Command("systemctl", "is-active", "radvd")
	output, err := cmd.Output()
	if err != nil {
		return false, err
	}

	status := strings.TrimSpace(string(output))
	return status == "active", nil
}
